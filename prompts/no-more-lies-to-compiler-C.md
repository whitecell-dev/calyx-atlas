# NO MORE LIES TO THE METAL: C EDITION 
## MEMORY RULES 1. NO BARE MALLOC: Always use typed allocators BAD: void* buf = malloc(size); GOOD: buffer_t* buf = buffer_alloc(size); 2. NO FORGOTTEN FREES: Every allocator has a paired deallocator GOOD: buffer_t* buf = buffer_alloc(size); buffer_free(buf); // Immediately document pairing 3. NO WILD POINTERS: Use sentinel values for invalid pointers GOOD: #define INVALID_PTR ((void*)0xDEADBEEF) if (ptr == INVALID_PTR) return ERR_INVALID; ## TYPE RULES 1. NO MAGIC NUMBERS: Every constant gets a name BAD: if (status == 3) GOOD: if (status == STATUS_COMPLETE) 2. NO BARE TYPES: Use typedef for semantic meaning BAD: uint32_t id; GOOD: typedef uint32_t user_id_t; user_id_t id; 3. NO IMPLICIT CASTS: Make conversions explicit BAD: float f = i; // int to float GOOD: float f = (float)i; ## ERROR RULES 1. NO SILENT ERRORS: Every function documents error codes BAD: int process(data_t* d); // Might fail? GOOD: error_t process(data_t* d); // Returns error code 2. NO IGNORED RETURNS: Check every system call BAD: write(fd, buf, len); GOOD: ssize_t written = write(fd, buf, len); if (written != len) return ERR_IO; ## SAFETY RULES 1. NO BUFFER OVERRUNS: Always bounds-check BAD: memcpy(dest, src, n); GOOD: if (n > dest_size) return ERR_OVERFLOW; memcpy(dest, src, n); 2. NO DIVIDE BY ZERO: Validate denominators BAD: int avg = total / count; GOOD: if (count == 0) return ERR_DIV_ZERO; int avg = total / count; ## ATLAS INTEGRATION - Your Atlas shows: [Include summary from Atlas] - Frozen interfaces: [List of .h files that can't change] - Allowed modifications: [List of .c files you can edit] - Compilation flags: [CFLAGS from build system]
