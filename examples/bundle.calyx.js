// ======================================================================
// CALYX TYPESCRIPT BUNDLE - LLM OPTIMIZED FORMAT
// ======================================================================

export const CALYX_METADATA = {
  "format_version": "calyx-ts-1.0",
  "total_modules": 2,
  "layers": {
    "CORE": 2
  },
  "external_deps": [],
  "package_deps": {
    "@babel/parser": "^7.23.0",
    "@babel/traverse": "^7.23.0",
    "glob": "^10.3.0",
    "typescript": "^5.2.0"
  },
  "tsconfig": null,
  "generated_at": "2026-01-02T07:28:18.880Z"
};

// ======================================================================
// MODULE MAP (name ‚Üí metadata)
// ======================================================================
export const MODULE_MAP = {
  'tsjs-calyx': {
    path: 'tsjs-calyx.ts',
    layer: 'CORE',
    hasTypes: true,
    isReact: true,
    exports: [],
  },
  'git-for-logic': {
    path: 'git-for-logic.js',
    layer: 'CORE',
    hasTypes: false,
    isReact: false,
    exports: [],
  },
};

// ======================================================================
// DEPENDENCY GRAPH (module ‚Üí [dependencies])
// ======================================================================
export const DEPENDENCY_GRAPH = {
  'tsjs-calyx': [],
  'git-for-logic': [],
};

// ======================================================================
// MODULE CONTENTS (PRESERVED EXACTLY)
// ======================================================================
export const MODULE_CONTENTS = {
  // ------------------------------------------------------------
  // MODULE: tsjs-calyx
  // LAYER: CORE
  // PATH: tsjs-calyx.ts
  // ------------------------------------------------------------
  'tsjs-calyx': `#!/usr/bin/env node\n/**\n * CALYX-OPTIMIZED TYPESCRIPT/JAVASCRIPT BUNDLER\n * \n * Bundles TypeScript/JavaScript modules into a single file FOR LLM CONSUMPTION.\n * Special handling for:\n * - ES Modules vs CommonJS\n * - TypeScript types and interfaces\n * - Module resolution (.ts, .tsx, .js, .jsx, .mjs, .cjs)\n * - Package.json dependencies\n * \n * USAGE:\n *   npx tsx calyx_bundle.ts --output bundle.calyx.js\n *   # Then in ChatGPT/Claude: "Here's my bundled TypeScript project..."\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { glob } from 'glob';\nimport * as ts from 'typescript';\nimport { parse } from '@babel/parser';\nimport traverse from '@babel/traverse';\nimport * as t from '@babel/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface CalyxModule {\n  name: string;                     // "@app/components/Button"\n  path: string;                     // "src/components/Button.tsx"\n  source: string;                   // Original source (preserved exactly)\n  imports: ImportSpec[];            // All imports with types\n  exports: ExportSpec[];            // What this module exports\n  dependencies: string[];           // Internal dependencies only\n  category: string;                 // "UI", "API", "UTILS", etc.\n  hasTypes: boolean;                // TypeScript file\n  isReact: boolean;                 // React component\n  packageExports?: string[];        // From package.json exports\n}\n\ninterface ImportSpec {\n  source: string;                   // "./utils" or "react"\n  specifiers: ImportSpecifier[];    // {name: "Component", alias?: "Comp"}\n  isTypeOnly: boolean;              // import type\n  isDefault: boolean;               // import React from "react"\n}\n\ninterface ImportSpecifier {\n  name: string;                     // "useState"\n  alias?: string;                   // "useState as state"\n  isType?: boolean;                 // TypeScript type import\n}\n\ninterface ExportSpec {\n  name: string;                     // "Button" or "default"\n  type: 'named' | 'default' | 'namespace' | 'type';\n  isTypeOnly?: boolean;             // export type { Props }\n  value?: any;                      // For default exports with values\n}\n\ninterface CalyxMetadata {\n  format_version: string;\n  total_modules: number;\n  layers: Record<string, number>;\n  external_deps: Set<string>;\n  package_deps: Record<string, string>;\n  tsconfig?: any;\n  generated_at: string;\n}\n\n// ============================================================================\n// MAIN CLASS\n// ============================================================================\n\nclass CalyxTSBundler {\n  private root: string;\n  private verbose: boolean;\n  private modules: Map<string, CalyxModule>;\n  private tsConfig: any;\n  private packageJson: any;\n\n  constructor(root: string = '.', verbose: boolean = false) {\n    this.root = path.resolve(root);\n    this.verbose = verbose;\n    this.modules = new Map();\n    this.tsConfig = this.loadTSConfig();\n    this.packageJson = this.loadPackageJson();\n  }\n\n  private log(msg: string): void {\n    if (this.verbose) {\n      console.log(\`[CALYX-TS] \${msg}\`);\n    }\n  }\n\n  private loadTSConfig(): any {\n    const tsConfigPath = path.join(this.root, 'tsconfig.json');\n    if (fs.existsSync(tsConfigPath)) {\n      try {\n        const content = fs.readFileSync(tsConfigPath, 'utf-8');\n        return JSON.parse(content);\n      } catch (e) {\n        this.log(\`Failed to parse tsconfig.json: \${e}\`);\n      }\n    }\n    return null;\n  }\n\n  private loadPackageJson(): any {\n    const packagePath = path.join(this.root, 'package.json');\n    if (fs.existsSync(packagePath)) {\n      try {\n        const content = fs.readFileSync(packagePath, 'utf-8');\n        return JSON.parse(content);\n      } catch (e) {\n        this.log(\`Failed to parse package.json: \${e}\`);\n      }\n    }\n    return null;\n  }\n\n  private detectCategory(filePath: string): string {\n    const relPath = path.relative(this.root, filePath);\n    const parts = relPath.split(path.sep);\n    \n    if (parts.length > 0) {\n      const first = parts[0].toLowerCase();\n      const second = parts[1]?.toLowerCase();\n      \n      // React/UI detection\n      if (first.includes('component') || first.includes('ui')) return 'UI';\n      if (second?.includes('component') || relPath.includes('.tsx')) return 'UI';\n      \n      // API/Server detection\n      if (first.includes('api') || first.includes('server')) return 'API';\n      if (first.includes('route') || first.includes('endpoint')) return 'API';\n      \n      // State management\n      if (first.includes('store') || first.includes('state')) return 'STATE';\n      \n      // Utils/Helpers\n      if (first.includes('util') || first.includes('helper')) return 'UTILS';\n      \n      // Hooks\n      if (first.includes('hook')) return 'HOOKS';\n      \n      // Types\n      if (first.includes('type') || first.includes('interface')) return 'TYPES';\n      \n      // Tests\n      if (first.includes('test') || first.includes('spec')) return 'TESTS';\n    }\n    \n    return 'CORE';\n  }\n\n  private parseImports(source: string, filePath: string): ImportSpec[] {\n    const imports: ImportSpec[] = [];\n    \n    try {\n      const ast = parse(source, {\n        sourceType: 'module',\n        plugins: [\n          'typescript',\n          'jsx',\n          'decorators-legacy',\n          'classProperties'\n        ]\n      });\n\n      traverse(ast, {\n        ImportDeclaration(path) {\n          const importSpec: ImportSpec = {\n            source: path.node.source.value,\n            specifiers: [],\n            isTypeOnly: path.node.importKind === 'type',\n            isDefault: false\n          };\n\n          path.node.specifiers.forEach(spec => {\n            if (t.isImportDefaultSpecifier(spec)) {\n              importSpec.specifiers.push({ name: 'default', alias: spec.local.name });\n              importSpec.isDefault = true;\n            } else if (t.isImportSpecifier(spec)) {\n              const name = t.isStringLiteral(spec.imported) \n                ? spec.imported.value \n                : spec.imported.name;\n              importSpec.specifiers.push({\n                name,\n                alias: spec.local.name !== name ? spec.local.name : undefined,\n                isType: path.node.importKind === 'type'\n              });\n            } else if (t.isImportNamespaceSpecifier(spec)) {\n              importSpec.specifiers.push({ \n                name: '*', \n                alias: spec.local.name \n              });\n            }\n          });\n\n          imports.push(importSpec);\n        }\n      });\n    } catch (error) {\n      this.log(\`Failed to parse imports for \${filePath}: \${error}\`);\n    }\n\n    return imports;\n  }\n\n  private parseExports(source: string, filePath: string): ExportSpec[] {\n    const exports: ExportSpec[] = [];\n    \n    try {\n      const ast = parse(source, {\n        sourceType: 'module',\n        plugins: [\n          'typescript',\n          'jsx',\n          'decorators-legacy',\n          'classProperties'\n        ]\n      });\n\n      traverse(ast, {\n        ExportNamedDeclaration(path) {\n          if (path.node.declaration) {\n            // export function/class/const\n            if (t.isFunctionDeclaration(path.node.declaration)) {\n              exports.push({\n                name: path.node.declaration.id?.name || 'anonymous',\n                type: 'named'\n              });\n            } else if (t.isClassDeclaration(path.node.declaration)) {\n              exports.push({\n                name: path.node.declaration.id?.name || 'anonymous',\n                type: 'named'\n              });\n            } else if (t.isVariableDeclaration(path.node.declaration)) {\n              path.node.declaration.declarations.forEach(decl => {\n                if (t.isIdentifier(decl.id)) {\n                  exports.push({ name: decl.id.name, type: 'named' });\n                }\n              });\n            } else if (t.isTSInterfaceDeclaration(path.node.declaration)) {\n              exports.push({\n                name: path.node.declaration.id.name,\n                type: 'type',\n                isTypeOnly: true\n              });\n            } else if (t.isTSTypeAliasDeclaration(path.node.declaration)) {\n              exports.push({\n                name: path.node.declaration.id.name,\n                type: 'type',\n                isTypeOnly: true\n              });\n            }\n          }\n\n          // export { x, y } from './module'\n          if (path.node.specifiers && path.node.source) {\n            path.node.specifiers.forEach(spec => {\n              if (t.isExportSpecifier(spec)) {\n                const name = t.isStringLiteral(spec.exported) \n                  ? spec.exported.value \n                  : spec.exported.name;\n                const local = t.isStringLiteral(spec.local) \n                  ? spec.local.value \n                  : spec.local.name;\n                \n                exports.push({\n                  name,\n                  type: 'named',\n                  isTypeOnly: path.node.exportKind === 'type'\n                });\n              }\n            });\n          }\n        },\n\n        ExportDefaultDeclaration(path) {\n          let name = 'default';\n          if (t.isIdentifier(path.node.declaration)) {\n            name = path.node.declaration.name;\n          } else if (t.isFunctionDeclaration(path.node.declaration) && path.node.declaration.id) {\n            name = path.node.declaration.id.name;\n          } else if (t.isClassDeclaration(path.node.declaration) && path.node.declaration.id) {\n            name = path.node.declaration.id.name;\n          }\n          \n          exports.push({ name, type: 'default' });\n        },\n\n        ExportAllDeclaration(path) {\n          exports.push({ \n            name: '*', \n            type: 'namespace',\n            isTypeOnly: path.node.exportKind === 'type'\n          });\n        }\n      });\n    } catch (error) {\n      this.log(\`Failed to parse exports for \${filePath}: \${error}\`);\n    }\n\n    return exports;\n  }\n\n  private analyzeModule(filePath: string): CalyxModule | null {\n    try {\n      const source = fs.readFileSync(filePath, 'utf-8');\n      const relPath = path.relative(this.root, filePath);\n      \n      // Generate module name\n      let moduleName = relPath\n        .replace(/\\.(ts|tsx|js|jsx|mjs|cjs)\$/, '')\n        .replace(/\\\\/g, '/');\n      \n      // Handle index files\n      if (moduleName.endsWith('/index')) {\n        moduleName = moduleName.slice(0, -6);\n      }\n      \n      // Convert to package-like name\n      if (moduleName.startsWith('src/')) {\n        moduleName = \`@app/\${moduleName.slice(4)}\`;\n      }\n\n      const imports = this.parseImports(source, filePath);\n      const exports = this.parseExports(source, filePath);\n      const category = this.detectCategory(filePath);\n      const hasTypes = filePath.endsWith('.ts') || filePath.endsWith('.tsx');\n      const isReact = filePath.endsWith('.tsx') || filePath.endsWith('.jsx') || \n                     source.includes('React') || source.includes('createElement');\n\n      // Determine internal dependencies\n      const dependencies = imports\n        .filter(imp => {\n          // Check if import is internal (starts with . or @app/)\n          return imp.source.startsWith('.') || imp.source.startsWith('@app/');\n        })\n        .map(imp => {\n          // Resolve relative paths to module names\n          if (imp.source.startsWith('.')) {\n            const resolved = path.resolve(path.dirname(filePath), imp.source);\n            const relative = path.relative(this.root, resolved);\n            return relative\n              .replace(/\\.(ts|tsx|js|jsx|mjs|cjs)\$/, '')\n              .replace(/\\\\/g, '/');\n          }\n          return imp.source;\n        });\n\n      return {\n        name: moduleName,\n        path: relPath,\n        source,\n        imports,\n        exports,\n        dependencies: [...new Set(dependencies)], // Remove duplicates\n        category,\n        hasTypes,\n        isReact\n      };\n    } catch (error) {\n      this.log(\`Failed to analyze \${filePath}: \${error}\`);\n      return null;\n    }\n  }\n\n  public async discover(patterns: string[] = ['**/*.{ts,tsx,js,jsx,mjs,cjs}']): Promise<void> {\n    const excludedDirs = new Set([\n      'node_modules',\n      '.git',\n      '.next',\n      'dist',\n      'build',\n      '.turbo',\n      '.cache',\n      '__tests__',\n      '__mocks__',\n      'coverage'\n    ]);\n\n    for (const pattern of patterns) {\n      const files = await glob(pattern, {\n        cwd: this.root,\n        ignore: ['**/node_modules/**', '**/dist/**', '**/build/**'],\n        absolute: true\n      });\n\n      for (const filePath of files) {\n        // Skip excluded directories\n        const relPath = path.relative(this.root, filePath);\n        const parts = relPath.split(path.sep);\n        if (parts.some(part => excludedDirs.has(part))) {\n          continue;\n        }\n\n        // Skip test files unless explicitly included\n        if (filePath.includes('.test.') || filePath.includes('.spec.')) {\n          continue;\n        }\n\n        const module = this.analyzeModule(filePath);\n        if (module) {\n          this.modules.set(module.name, module);\n          this.log(\`Analyzed: \${module.name} (\${module.category})\`);\n        }\n      }\n    }\n  }\n\n  private buildDependencyGraph(): Map<string, string[]> {\n    const graph = new Map<string, string[]>();\n\n    for (const [name, module] of this.modules) {\n      const deps = new Set<string>();\n      \n      for (const dep of module.dependencies) {\n        // Try to find the dependency in our modules\n        let found = false;\n        \n        // Exact match\n        if (this.modules.has(dep)) {\n          deps.add(dep);\n          found = true;\n        }\n        \n        // Try with @app/ prefix\n        if (!found && !dep.startsWith('@app/') && this.modules.has(\`@app/\${dep}\`)) {\n          deps.add(\`@app/\${dep}\`);\n          found = true;\n        }\n        \n        // Try removing @app/ prefix\n        if (!found && dep.startsWith('@app/') && this.modules.has(dep.slice(5))) {\n          deps.add(dep.slice(5));\n          found = true;\n        }\n        \n        // Try index resolution\n        if (!found && this.modules.has(\`\${dep}/index\`)) {\n          deps.add(\`\${dep}/index\`);\n        }\n      }\n      \n      graph.set(name, Array.from(deps));\n    }\n\n    // Topological sort\n    const visited = new Set<string>();\n    const temp = new Set<string>();\n    const sorted: string[] = [];\n\n    const visit = (node: string) => {\n      if (temp.has(node)) {\n        this.log(\`WARNING: Circular dependency detected: \${node}\`);\n        return;\n      }\n      if (visited.has(node)) return;\n\n      temp.add(node);\n      for (const dep of graph.get(node) || []) {\n        if (this.modules.has(dep)) {\n          visit(dep);\n        }\n      }\n      temp.delete(node);\n      visited.add(node);\n      sorted.push(node);\n    };\n\n    for (const node of this.modules.keys()) {\n      if (!visited.has(node)) {\n        visit(node);\n      }\n    }\n\n    // Reorder modules\n    const sortedModules = new Map<string, CalyxModule>();\n    for (const name of sorted) {\n      const module = this.modules.get(name);\n      if (module) {\n        sortedModules.set(name, module);\n      }\n    }\n    this.modules = sortedModules;\n\n    return graph;\n  }\n\n  public generateBundle(outputPath: string): string {\n    // Build metadata\n    const metadata: CalyxMetadata = {\n      format_version: 'calyx-ts-1.0',\n      total_modules: this.modules.size,\n      layers: {},\n      external_deps: new Set<string>(),\n      package_deps: this.packageJson?.dependencies || {},\n      tsconfig: this.tsConfig,\n      generated_at: new Date().toISOString()\n    };\n\n    // Count by layer and collect external dependencies\n    for (const module of this.modules.values()) {\n      metadata.layers[module.category] = (metadata.layers[module.category] || 0) + 1;\n      \n      for (const imp of module.imports) {\n        // Check if this is external\n        const isExternal = !imp.source.startsWith('.') && \n                          !imp.source.startsWith('@app/') &&\n                          !this.modules.has(imp.source);\n        \n        if (isExternal) {\n          metadata.external_deps.add(imp.source);\n        }\n      }\n    }\n\n    // Build dependency graph\n    const graph = this.buildDependencyGraph();\n\n    // Generate bundle content\n    const lines: string[] = [];\n\n    // ==================== SECTION 1: METADATA ====================\n    lines.push('// ' + '='.repeat(70));\n    lines.push('// CALYX TYPESCRIPT BUNDLE - LLM OPTIMIZED FORMAT');\n    lines.push('// ' + '='.repeat(70));\n    lines.push('');\n    lines.push(\`export const CALYX_METADATA = \${JSON.stringify({\n      ...metadata,\n      external_deps: Array.from(metadata.external_deps).sort()\n    }, null, 2)};\`);\n    lines.push('');\n\n    // ==================== SECTION 2: MODULE MAP ====================\n    lines.push('// ' + '='.repeat(70));\n    lines.push('// MODULE MAP (name ‚Üí metadata)');\n    lines.push('// ' + '='.repeat(70));\n    lines.push('export const MODULE_MAP = {');\n    for (const [name, module] of this.modules) {\n      lines.push(\`  '\${name}': {\`);\n      lines.push(\`    path: '\${module.path}',\`);\n      lines.push(\`    layer: '\${module.category}',\`);\n      lines.push(\`    hasTypes: \${module.hasTypes},\`);\n      lines.push(\`    isReact: \${module.isReact},\`);\n      lines.push(\`    exports: \${JSON.stringify(module.exports.map(e => e.name))},\`);\n      lines.push(\`  },\`);\n    }\n    lines.push('};');\n    lines.push('');\n\n    // ==================== SECTION 3: DEPENDENCY GRAPH ====================\n    lines.push('// ' + '='.repeat(70));\n    lines.push('// DEPENDENCY GRAPH (module ‚Üí [dependencies])');\n    lines.push('// ' + '='.repeat(70));\n    lines.push('export const DEPENDENCY_GRAPH = {');\n    for (const [name, deps] of graph) {\n      lines.push(\`  '\${name}': \${JSON.stringify(deps)},\`);\n    }\n    lines.push('};');\n    lines.push('');\n\n    // ==================== SECTION 4: MODULE CONTENTS ====================\n    lines.push('// ' + '='.repeat(70));\n    lines.push('// MODULE CONTENTS (PRESERVED EXACTLY)');\n    lines.push('// ' + '='.repeat(70));\n    lines.push('export const MODULE_CONTENTS = {');\n    for (const [name, module] of this.modules) {\n      lines.push(\`  // \${'-'.repeat(60)}\`);\n      lines.push(\`  // MODULE: \${name}\`);\n      lines.push(\`  // LAYER: \${module.category}\`);\n      lines.push(\`  // PATH: \${module.path}\`);\n      lines.push(\`  // \${'-'.repeat(60)}\`);\n      lines.push(\`  '\${name}': \\\`\${this.escapeTemplateLiteral(module.source)}\\\`,\`);\n      lines.push('');\n    }\n    lines.push('};');\n    lines.push('');\n\n    // ==================== SECTION 5: PUBLIC API ====================\n    lines.push('// ' + '='.repeat(70));\n    lines.push('// PUBLIC API (what to expose)');\n    lines.push('// ' + '='.repeat(70));\n    lines.push('');\n    lines.push('/**');\n    lines.push(' * Retrieve module source by name');\n    lines.push(' */');\n    lines.push('export function getModule(name: string): string {');\n    lines.push('  return MODULE_CONTENTS[name as keyof typeof MODULE_CONTENTS] || "";');\n    lines.push('}');\n    lines.push('');\n    lines.push('/**');\n    lines.push(' * List modules, optionally filtered by layer');\n    lines.push(' */');\n    lines.push('export function listModules(layer?: string): string[] {');\n    lines.push('  if (layer) {');\n    lines.push('    return Object.entries(MODULE_MAP)');\n    lines.push('      .filter(([_, meta]) => meta.layer === layer)');\n    lines.push('      .map(([name]) => name);');\n    lines.push('  }');\n    lines.push('  return Object.keys(MODULE_CONTENTS);');\n    lines.push('}');\n    lines.push('');\n    lines.push('/**');\n    lines.push(' * Get module dependencies');\n    lines.push(' */');\n    lines.push('export function getDependencies(name: string): string[] {');\n    lines.push('  return DEPENDENCY_GRAPH[name as keyof typeof DEPENDENCY_GRAPH] || [];');\n    lines.push('}');\n    lines.push('');\n    lines.push('/**');\n    lines.push(' * Get statistics by layer');\n    lines.push(' */');\n    lines.push('export function getLayerStats(): Record<string, number> {');\n    lines.push('  return CALYX_METADATA.layers;');\n    lines.push('}');\n    lines.push('');\n    lines.push('/**');\n    lines.push(' * Get external dependencies');\n    lines.push(' */');\n    lines.push('export function getExternalDeps(): string[] {');\n    lines.push('  return CALYX_METADATA.external_deps;');\n    lines.push('}');\n    lines.push('');\n    lines.push('/**');\n    lines.push(' * Get package.json dependencies');\n    lines.push(' */');\n    lines.push('export function getPackageDeps(): Record<string, string> {');\n    lines.push('  return CALYX_METADATA.package_deps;');\n    lines.push('}');\n    lines.push('');\n\n    // ==================== SECTION 6: IMPORT SHIM ====================\n    lines.push('// ' + '='.repeat(70));\n    lines.push('// RUNTIME SHIM (for Node.js execution)');\n    lines.push('// ' + '='.repeat(70));\n    lines.push('if (typeof require !== "undefined" && require.cache) {');\n    lines.push('  // Only create packages that exist in our bundle');\n    lines.push('  const packages = new Set(');\n    lines.push('    Object.keys(MODULE_CONTENTS)');\n    lines.push('      .map(name => name.split(".")[0])');\n    lines.push('      .filter(Boolean)');\n    lines.push('  );');\n    lines.push('');\n    lines.push('  for (const pkg of packages) {');\n    lines.push('    // Create package in require.cache');\n    lines.push('    const pkgName = \`calyx.\${pkg}\`;');\n    lines.push('    const pkgModule = { exports: {} };');\n    lines.push('    require.cache[pkgName] = pkgModule;');\n    lines.push('');\n    lines.push('    // Add submodules');\n    lines.push('    for (const [fullName, content] of Object.entries(MODULE_CONTENTS)) {');\n    lines.push('      if (fullName.startsWith(\`\${pkg}.\`)) {');\n    lines.push('        const subName = fullName.slice(pkg.length + 1);');\n    lines.push('        const subFull = \`\${pkgName}.\${subName}\`;');\n    lines.push('');\n    lines.push('        // Execute module in its own context');\n    lines.push('        const module = { exports: {} };');\n    lines.push('        const wrapper = \`(function(exports, module) {');\n    lines.push('          \${content.replace(/\\\\\\\\/g, "\\\\\\\\\\\\\\\\").replace(/\`/g, "\\\\\\\\\`")}');\n    lines.push('        })\`;');\n    lines.push('        try {');\n    lines.push('          eval(wrapper)(module.exports, module);');\n    lines.push('          require.cache[subFull] = { exports: module.exports };');\n    lines.push('          pkgModule.exports[subName] = module.exports;');\n    lines.push('        } catch (error) {');\n    lines.push('          console.error(\`Failed to load \${subFull}:\`, error);');\n    lines.push('        }');\n    lines.push('      }');\n    lines.push('    }');\n    lines.push('  }');\n    lines.push('}');\n    lines.push('');\n\n    // ==================== SECTION 7: TYPE DECLARATIONS ====================\n    if (this.hasTypeScriptFiles()) {\n      lines.push('// ' + '='.repeat(70));\n      lines.push('// TYPE DECLARATIONS (for TypeScript awareness)');\n      lines.push('// ' + '='.repeat(70));\n      lines.push('declare global {');\n      lines.push('  namespace Calyx {');\n      lines.push('    interface ModuleMetadata {');\n      lines.push('      path: string;');\n      lines.push('      layer: string;');\n      lines.push('      hasTypes: boolean;');\n      lines.push('      isReact: boolean;');\n      lines.push('      exports: string[];');\n      lines.push('    }');\n      lines.push('');\n      lines.push('    interface Atlas {');\n      lines.push('      metadata: typeof CALYX_METADATA;');\n      lines.push('      modules: typeof MODULE_MAP;');\n      lines.push('      dependencies: typeof DEPENDENCY_GRAPH;');\n      lines.push('    }');\n      lines.push('  }');\n      lines.push('}');\n      lines.push('');\n    }\n\n    // ==================== SECTION 8: MAIN ENTRY ====================\n    lines.push('// ' + '='.repeat(70));\n    lines.push('// MAIN ENTRY POINT (if run as script)');\n    lines.push('// ' + '='.repeat(70));\n    lines.push('if (typeof module !== "undefined" && require.main === module) {');\n    lines.push('  console.log("CALYX TypeScript Bundle Loaded");');\n    lines.push('  console.log(\`Modules: \${Object.keys(MODULE_CONTENTS).length}\`);');\n    lines.push('  console.log(\`Layers: \${JSON.stringify(getLayerStats())}\`);');\n    lines.push('  console.log("");');\n    lines.push('  console.log("Available commands:");');\n    lines.push('  console.log("  - getModule(name)");');\n    lines.push('  console.log("  - listModules(layer)");');\n    lines.push('  console.log("  - getDependencies(name)");');\n    lines.push('  console.push("  - getLayerStats()");');\n    lines.push('  console.log("  - getExternalDeps()");');\n    lines.push('  console.log("  - getPackageDeps()");');\n    lines.push('}');\n    lines.push('');\n\n    // Write to file\n    const content = lines.join('\\n');\n    const outputFile = path.join(this.root, outputPath);\n    fs.writeFileSync(outputFile, content, 'utf-8');\n\n    this.log(\`Bundle written: \${outputFile}\`);\n\n    // Stats\n    console.log('\\n' + '='.repeat(60));\n    console.log('CALYX TYPESCRIPT BUNDLE COMPLETE');\n    console.log('='.repeat(60));\n    console.log(\`Output: \${outputFile}\`);\n    console.log(\`Modules: \${this.modules.size}\`);\n    console.log(\`Layers: \${JSON.stringify(metadata.layers)}\`);\n    console.log(\`TypeScript files: \${Array.from(this.modules.values()).filter(m => m.hasTypes).length}\`);\n    console.log(\`React components: \${Array.from(this.modules.values()).filter(m => m.isReact).length}\`);\n    console.log(\`External dependencies: \${metadata.external_deps.size}\`);\n    console.log(\`Size: \${(content.length / 1024).toFixed(1)} KB\`);\n    console.log('='.repeat(60));\n\n    return outputFile;\n  }\n\n  private escapeTemplateLiteral(str: string): string {\n    return str\n      .replace(/\\\\/g, '\\\\\\\\')      // Escape backslashes\n      .replace(/\`/g, '\\\\\`')        // Escape backticks\n      .replace(/\\\$/g, '\\\\\$')       // Escape dollar signs\n      .replace(/\\r?\\n/g, '\\\\n');   // Preserve newlines\n  }\n\n  private hasTypeScriptFiles(): boolean {\n    return Array.from(this.modules.values()).some(m => m.hasTypes);\n  }\n}\n\n// ============================================================================\n// COMMAND LINE INTERFACE\n// ============================================================================\n\nasync function main() {\n  const args = process.argv.slice(2);\n  \n  let output = 'calyx_bundle.js';\n  let root = '.';\n  let verbose = false;\n  const patterns: string[] = [];\n\n  for (let i = 0; i < args.length; i++) {\n    switch (args[i]) {\n      case '--output':\n      case '-o':\n        output = args[++i];\n        break;\n      case '--root':\n      case '-r':\n        root = args[++i];\n        break;\n      case '--verbose':\n      case '-v':\n        verbose = true;\n        break;\n      case '--patterns':\n      case '-p':\n        patterns.push(args[++i]);\n        break;\n      case '--help':\n      case '-h':\n        console.log(\`\nCALYX TypeScript/JavaScript Bundler\n\nUsage:\n  npx tsx calyx_bundle.ts [options]\n\nOptions:\n  -o, --output FILE    Output file (default: calyx_bundle.js)\n  -r, --root DIR       Project root (default: .)\n  -p, --patterns PAT   Glob patterns (can specify multiple)\n  -v, --verbose        Verbose output\n  -h, --help           Show this help\n\nExamples:\n  # Bundle all TypeScript/JavaScript files\n  npx tsx calyx_bundle.ts --output bundle.calyx.js\n  \n  # Bundle specific patterns\n  npx tsx calyx_bundle.ts --patterns "src/**/*.ts" --patterns "src/**/*.tsx"\n  \n  # Bundle with verbose output\n  npx tsx calyx_bundle.ts --verbose --root ./my-project\n        \`);\n        process.exit(0);\n      default:\n        if (!args[i].startsWith('-')) {\n          patterns.push(args[i]);\n        }\n    }\n  }\n\n  // Default patterns if none specified\n  if (patterns.length === 0) {\n    patterns.push('**/*.{ts,tsx,js,jsx,mjs,cjs}');\n  }\n\n  const bundler = new CalyxTSBundler(root, verbose);\n  await bundler.discover(patterns);\n  bundler.generateBundle(output);\n}\n\nif (import.meta.url === \`file://\${process.argv[1]}\`) {\n  main().catch(console.error);\n}\n\nexport { CalyxTSBundler };\n`,

  // ------------------------------------------------------------
  // MODULE: git-for-logic
  // LAYER: CORE
  // PATH: git-for-logic.js
  // ------------------------------------------------------------
  'git-for-logic': `#!/usr/bin/env node\n\n/**\n * Git for Logic - Merged Implementation\n * Content-addressed version control for business logic execution\n * Combines Git internals with deterministic rule evaluation\n */\n\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst path = require('path');\nconst yaml = require('js-yaml');\nconst sqlite3 = require('sqlite3').verbose();\n\nclass GitForLogic {\n  constructor(repoPath = './logic-repo') {\n    this.repoPath = repoPath;\n    this.dbPath = path.join(repoPath, '.logicgit', 'state.db');\n    this.currentBranch = 'main';\n    this.ensureRepoStructure();\n  }\n\n  // Initialize repository structure (like git init)\n  ensureRepoStructure() {\n    const dirs = [\n      this.repoPath,\n      path.join(this.repoPath, '.logicgit'),\n      path.join(this.repoPath, '.logicgit', 'objects'),\n      path.join(this.repoPath, '.logicgit', 'refs', 'heads'),\n      path.join(this.repoPath, 'rules'),\n      path.join(this.repoPath, 'data'),\n      path.join(this.repoPath, 'exports')\n    ];\n    \n    dirs.forEach(dir => {\n      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n    });\n    \n    // Initialize HEAD if it doesn't exist\n    const headPath = path.join(this.repoPath, '.logicgit', 'HEAD');\n    if (!fs.existsSync(headPath)) {\n      fs.writeFileSync(headPath, 'ref: refs/heads/main\\n');\n    }\n\n    // Initialize main branch if it doesn't exist\n    const mainPath = path.join(this.repoPath, '.logicgit', 'refs', 'heads', 'main');\n    if (!fs.existsSync(mainPath)) {\n      fs.writeFileSync(mainPath, ''); // Empty until first commit\n    }\n  }\n\n  // Initialize database (lazy loading)\n  async initDatabase() {\n    if (this.db) return this.db;\n\n    return new Promise((resolve, reject) => {\n      this.db = new sqlite3.Database(this.dbPath, (err) => {\n        if (err) return reject(err);\n        \n        this.createTables().then(() => {\n          console.log(\`üîß Database initialized: \${this.dbPath}\`);\n          resolve(this.db);\n        }).catch(reject);\n      });\n    });\n  }\n\n  async createTables() {\n    const statements = [\n      // Git-style objects storage\n      \`CREATE TABLE IF NOT EXISTS objects (\n        hash TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        content TEXT NOT NULL,\n        size INTEGER,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\`,\n      \n      // Execution history (like git log)\n      \`CREATE TABLE IF NOT EXISTS executions (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_hash TEXT UNIQUE NOT NULL,\n        commit_hash TEXT,\n        parent_hash TEXT,\n        rules_file TEXT NOT NULL,\n        rules_hash TEXT NOT NULL,\n        input_hash TEXT NOT NULL,\n        output_hash TEXT NOT NULL,\n        applied_rules TEXT NOT NULL,\n        execution_time_ms INTEGER,\n        branch TEXT DEFAULT 'main',\n        message TEXT,\n        author TEXT DEFAULT 'logic-git',\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\`,\n\n      // Audit trail (MNEME-style)\n      \`CREATE TABLE IF NOT EXISTS audit_trail (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_hash TEXT REFERENCES executions(execution_hash),\n        rule_name TEXT NOT NULL,\n        condition_text TEXT NOT NULL,\n        changes_json TEXT NOT NULL,\n        state_before TEXT,\n        state_after TEXT,\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\`,\n\n      // State snapshots for debugging\n      \`CREATE TABLE IF NOT EXISTS state_snapshots (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_hash TEXT REFERENCES executions(execution_hash),\n        snapshot_type TEXT DEFAULT 'final',\n        state_data TEXT NOT NULL,\n        state_hash TEXT NOT NULL,\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\`\n    ];\n\n    const indexes = [\n      \`CREATE INDEX IF NOT EXISTS idx_executions_hash ON executions(execution_hash)\`,\n      \`CREATE INDEX IF NOT EXISTS idx_executions_time ON executions(timestamp)\`,\n      \`CREATE INDEX IF NOT EXISTS idx_executions_branch ON executions(branch)\`,\n      \`CREATE INDEX IF NOT EXISTS idx_audit_execution ON audit_trail(execution_hash)\`\n    ];\n\n    // Execute statements\n    for (const stmt of [...statements, ...indexes]) {\n      await new Promise((resolve, reject) => {\n        this.db.run(stmt, (err) => err ? reject(err) : resolve());\n      });\n    }\n  }\n\n  // Content-addressed storage (Git-style)\n  async hashObject(content, type = 'blob') {\n    await this.initDatabase();\n    \n    const contentStr = typeof content === 'string' ? content : JSON.stringify(content, null, 2);\n    const header = \`\${type} \${contentStr.length}\\0\`;\n    const hash = crypto.createHash('sha1').update(header + contentStr).digest('hex');\n    \n    // Store in database\n    await new Promise((resolve, reject) => {\n      this.db.run(\n        'INSERT OR REPLACE INTO objects (hash, type, content, size) VALUES (?, ?, ?, ?)',\n        [hash, type, contentStr, contentStr.length],\n        (err) => err ? reject(err) : resolve()\n      );\n    });\n\n    // Also store in filesystem for Git compatibility\n    const objectDir = path.join(this.repoPath, '.logicgit', 'objects', hash.substring(0, 2));\n    const objectFile = path.join(objectDir, hash.substring(2));\n    \n    if (!fs.existsSync(objectDir)) {\n      fs.mkdirSync(objectDir, { recursive: true });\n    }\n    \n    if (!fs.existsSync(objectFile)) {\n      fs.writeFileSync(objectFile, contentStr);\n    }\n\n    return hash;\n  }\n\n  // Load rules from YAML\n  loadRules(filename) {\n    const rulesPath = path.join(this.repoPath, 'rules', filename);\n    if (!fs.existsSync(rulesPath)) {\n      throw new Error(\`Rules file not found: \${rulesPath}\`);\n    }\n    \n    const content = fs.readFileSync(rulesPath, 'utf8');\n    return yaml.load(content);\n  }\n\n  // Load data (JSON or CSV)\n  loadData(filename) {\n    const dataPath = path.join(this.repoPath, 'data', filename);\n    if (!fs.existsSync(dataPath)) {\n      throw new Error(\`Data file not found: \${dataPath}\`);\n    }\n\n    const content = fs.readFileSync(dataPath, 'utf8');\n    \n    if (filename.endsWith('.json')) {\n      return JSON.parse(content);\n    } else if (filename.endsWith('.csv')) {\n      return this.parseCsv(content);\n    } else {\n      throw new Error('Unsupported data format. Use .json or .csv');\n    }\n  }\n\n  // Simple CSV parser\n  parseCsv(content) {\n    const lines = content.trim().split('\\n');\n    const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));\n    \n    return lines.slice(1).map(line => {\n      const values = line.split(',').map(v => v.trim().replace(/"/g, ''));\n      const obj = {};\n      headers.forEach((header, i) => {\n        const value = values[i] || '';\n        obj[header] = isNaN(value) || value === '' ? value : Number(value);\n      });\n      return obj;\n    });\n  }\n\n  // Evaluate rule conditions\n  evaluateCondition(condition, data) {\n    try {\n      // Simple and safe condition evaluation\n      const safeEval = condition.replace(/(\\w+\\.?\\w*)/g, (match) => {\n        if (match === 'true' || match === 'false' || match === 'null' || !isNaN(match)) {\n          return match;\n        }\n        return match.includes('.') ? \`data.\${match}\` : \`data.\${match}\`;\n      });\n      \n      // Use Function constructor for safer evaluation\n      const func = new Function('data', \`return \${safeEval}\`);\n      return func(data);\n    } catch (e) {\n      console.warn(\`‚ö†Ô∏è  Condition evaluation failed: \${condition} - \${e.message}\`);\n      return false;\n    }\n  }\n\n  // Set nested object values\n  setNestedValue(obj, path, value) {\n    const keys = path.split('.');\n    let current = obj;\n    \n    for (let i = 0; i < keys.length - 1; i++) {\n      if (!current[keys[i]] || typeof current[keys[i]] !== 'object') {\n        current[keys[i]] = {};\n      }\n      current = current[keys[i]];\n    }\n    \n    current[keys[keys.length - 1]] = value;\n  }\n\n  // Execute rules on data (deterministic)\n  async executeRules(rulesData, inputData, options = {}) {\n    const startTime = Date.now();\n    await this.initDatabase();\n    \n    // Sort rules by priority\n    const sortedRules = rulesData.rules.sort((a, b) => (a.priority || 999) - (b.priority || 999));\n    \n    // Deep clone input to avoid mutation\n    let state = JSON.parse(JSON.stringify(inputData));\n    const appliedRules = [];\n    const auditTrail = [];\n    \n    console.log(\`üöÄ Executing \${sortedRules.length} rules\`);\n    \n    for (const rule of sortedRules) {\n      const stateBefore = JSON.parse(JSON.stringify(state));\n      \n      if (this.evaluateCondition(rule.when, state)) {\n        console.log(\`‚úÖ Applied: \${rule.name}\`);\n        appliedRules.push(rule.name);\n        \n        // Apply transformations\n        for (const [key, value] of Object.entries(rule.then)) {\n          this.setNestedValue(state, key, value);\n        }\n        \n        auditTrail.push({\n          rule: rule.name,\n          condition: rule.when,\n          changes: rule.then,\n          stateBefore,\n          stateAfter: JSON.parse(JSON.stringify(state)),\n          timestamp: new Date().toISOString()\n        });\n      } else {\n        console.log(\`‚è∏Ô∏è  Skipped: \${rule.name}\`);\n      }\n    }\n\n    const executionTime = Date.now() - startTime;\n    \n    // Generate hashes\n    const rulesHash = this.generateHash(rulesData);\n    const inputHash = this.generateHash(inputData);\n    const outputHash = this.generateHash(state);\n    \n    // Create deterministic execution hash\n    const executionHash = this.generateHash({\n      rules: rulesHash,\n      input: inputHash,\n      output: outputHash,\n      appliedRules: appliedRules.sort() // Sort for determinism\n    });\n\n    const execution = {\n      executionHash,\n      rulesFile: options.rulesFile || 'unknown',\n      rulesHash,\n      inputHash,\n      outputHash,\n      appliedRules,\n      auditTrail,\n      finalState: state,\n      executionTime,\n      metadata: {\n        version: rulesData.metadata?.version || '1.0.0',\n        description: rulesData.metadata?.description || '',\n        ruleCount: sortedRules.length,\n        appliedCount: appliedRules.length,\n        timestamp: new Date().toISOString()\n      }\n    };\n\n    console.log(\`üèÅ Execution completed in \${executionTime}ms\`);\n    console.log(\`üìù Hash: \${executionHash.substring(0, 12)}\`);\n    \n    return execution;\n  }\n\n  // Git-style commit\n  async commit(execution, message = '', parentHash = null) {\n    await this.initDatabase();\n    \n    // Get current HEAD if no parent specified\n    if (!parentHash) {\n      parentHash = await this.getHeadCommit();\n    }\n\n    const commitData = {\n      execution: execution.executionHash,\n      parent: parentHash,\n      author: 'logic-git',\n      timestamp: new Date().toISOString(),\n      message: message || \`Execute \${execution.rulesFile}\`\n    };\n\n    const commitHash = await this.hashObject(commitData, 'commit');\n    \n    // Store execution in database\n    await new Promise((resolve, reject) => {\n      this.db.run(\`\n        INSERT INTO executions \n        (execution_hash, commit_hash, parent_hash, rules_file, rules_hash, \n         input_hash, output_hash, applied_rules, execution_time_ms, branch, message, timestamp)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      \`, [\n        execution.executionHash,\n        commitHash,\n        parentHash,\n        execution.rulesFile,\n        execution.rulesHash,\n        execution.inputHash,\n        execution.outputHash,\n        JSON.stringify(execution.appliedRules),\n        execution.executionTime,\n        this.currentBranch,\n        message,\n        execution.metadata.timestamp\n      ], (err) => err ? reject(err) : resolve());\n    });\n\n    // Store audit trail\n    for (const entry of execution.auditTrail) {\n      await new Promise((resolve, reject) => {\n        this.db.run(\`\n          INSERT INTO audit_trail \n          (execution_hash, rule_name, condition_text, changes_json, state_before, state_after)\n          VALUES (?, ?, ?, ?, ?, ?)\n        \`, [\n          execution.executionHash,\n          entry.rule,\n          entry.condition,\n          JSON.stringify(entry.changes),\n          JSON.stringify(entry.stateBefore),\n          JSON.stringify(entry.stateAfter)\n        ], (err) => err ? reject(err) : resolve());\n      });\n    }\n\n    // Store final state snapshot\n    await new Promise((resolve, reject) => {\n      this.db.run(\`\n        INSERT INTO state_snapshots \n        (execution_hash, snapshot_type, state_data, state_hash)\n        VALUES (?, ?, ?, ?)\n      \`, [\n        execution.executionHash,\n        'final',\n        JSON.stringify(execution.finalState),\n        execution.outputHash\n      ], (err) => err ? reject(err) : resolve());\n    });\n\n    // Update HEAD\n    await this.updateHead(commitHash);\n    \n    console.log(\`üíæ [\${commitHash.substring(0, 8)}] \${message}\`);\n    return commitHash;\n  }\n\n  // Execute and commit in one operation\n  async execute(rulesFile, dataFile, message = '') {\n    try {\n      console.log(\`\\nüéØ Git for Logic - Execute & Commit\`);\n      console.log(\`üìã Rules: \${rulesFile}\`);\n      console.log(\`üìä Data: \${dataFile}\`);\n      \n      const rulesData = this.loadRules(rulesFile);\n      const inputData = this.loadData(dataFile);\n      \n      // Handle array of records or single record\n      const records = Array.isArray(inputData) ? inputData : [inputData];\n      const results = [];\n      \n      for (let i = 0; i < records.length; i++) {\n        console.log(\`\\n--- Processing Record \${i + 1}/\${records.length} ---\`);\n        \n        const execution = await this.executeRules(rulesData, records[i], { rulesFile });\n        const commitMessage = message || \`Execute \${rulesFile} on record \${i + 1}\`;\n        const commitHash = await this.commit(execution, commitMessage);\n        \n        results.push({\n          recordIndex: i,\n          commitHash,\n          executionHash: execution.executionHash,\n          finalState: execution.finalState,\n          appliedRules: execution.appliedRules\n        });\n        \n        console.log(\`üéØ Final State:\`, JSON.stringify(execution.finalState, null, 2));\n      }\n      \n      return results;\n      \n    } catch (error) {\n      console.error('‚ùå Execution failed:', error.message);\n      throw error;\n    }\n  }\n\n  // Show execution history (like git log)\n  async log(limit = 10, branch = null) {\n    await this.initDatabase();\n    \n    const branchFilter = branch || this.currentBranch;\n    \n    const rows = await new Promise((resolve, reject) => {\n      this.db.all(\`\n        SELECT * FROM executions \n        WHERE branch = ?\n        ORDER BY timestamp DESC \n        LIMIT ?\n      \`, [branchFilter, limit], (err, rows) => {\n        err ? reject(err) : resolve(rows);\n      });\n    });\n\n    console.log(\`\\nüìö Logic Git History (\${branchFilter}):\\n\`);\n    \n    if (rows.length === 0) {\n      console.log('No executions found.');\n      return;\n    }\n\n    rows.forEach((exec, i) => {\n      const appliedRules = JSON.parse(exec.applied_rules);\n      console.log(\`commit \${exec.commit_hash.substring(0, 8)}\`);\n      console.log(\`Execution: \${exec.execution_hash.substring(0, 12)}\`);\n      console.log(\`Author: \${exec.author}\`);\n      console.log(\`Date: \${new Date(exec.timestamp).toLocaleString()}\`);\n      console.log(\`\\n    \${exec.message}\`);\n      console.log(\`    Rules: \${exec.rules_file} | Applied: \${appliedRules.length} | Time: \${exec.execution_time_ms}ms\\n\`);\n      if (i < rows.length - 1) console.log('---');\n    });\n  }\n\n  // Compare two executions (like git diff)\n  async diff(hash1, hash2) {\n    await this.initDatabase();\n    \n    const [exec1, exec2] = await Promise.all([\n      this.getExecution(hash1),\n      this.getExecution(hash2)\n    ]);\n\n    if (!exec1 || !exec2) {\n      console.error('‚ùå One or both executions not found');\n      return;\n    }\n\n    console.log(\`\\nüìä Diff \${hash1.substring(0, 8)}..\${hash2.substring(0, 8)}\\n\`);\n    \n    const rules1 = JSON.parse(exec1.applied_rules);\n    const rules2 = JSON.parse(exec2.applied_rules);\n    \n    const added = rules2.filter(r => !rules1.includes(r));\n    const removed = rules1.filter(r => !rules2.includes(r));\n    \n    console.log(\`Rules Changed: \${exec1.rules_hash !== exec2.rules_hash ? 'YES' : 'NO'}\`);\n    console.log(\`Output Changed: \${exec1.output_hash !== exec2.output_hash ? 'YES' : 'NO'}\`);\n    console.log(\`Time Diff: \${exec2.execution_time_ms - exec1.execution_time_ms}ms\`);\n    \n    if (added.length > 0) {\n      console.log(\`\\n‚ûï Rules Added:\`);\n      added.forEach(rule => console.log(\`   + \${rule}\`));\n    }\n    \n    if (removed.length > 0) {\n      console.log(\`\\n‚ûñ Rules Removed:\`);\n      removed.forEach(rule => console.log(\`   - \${rule}\`));\n    }\n    \n    if (added.length === 0 && removed.length === 0) {\n      console.log(\`\\n‚ú® Same rules applied\`);\n    }\n  }\n\n  // Branch operations\n  async createBranch(branchName) {\n    const headCommit = await this.getHeadCommit();\n    const branchPath = path.join(this.repoPath, '.logicgit', 'refs', 'heads', branchName);\n    \n    if (fs.existsSync(branchPath)) {\n      throw new Error(\`Branch \${branchName} already exists\`);\n    }\n    \n    fs.writeFileSync(branchPath, (headCommit || '') + '\\n');\n    console.log(\`üåø Created branch: \${branchName}\`);\n  }\n\n  async checkout(branchName) {\n    const branchPath = path.join(this.repoPath, '.logicgit', 'refs', 'heads', branchName);\n    \n    if (!fs.existsSync(branchPath)) {\n      throw new Error(\`Branch \${branchName} not found\`);\n    }\n    \n    const headPath = path.join(this.repoPath, '.logicgit', 'HEAD');\n    fs.writeFileSync(headPath, \`ref: refs/heads/\${branchName}\\n\`);\n    this.currentBranch = branchName;\n    \n    console.log(\`üåø Switched to branch: \${branchName}\`);\n  }\n\n  async listBranches() {\n    const refsDir = path.join(this.repoPath, '.logicgit', 'refs', 'heads');\n    const branches = fs.readdirSync(refsDir);\n    \n    console.log('\\nüåø Branches:');\n    branches.forEach(branch => {\n      const marker = branch === this.currentBranch ? '* ' : '  ';\n      console.log(\`\${marker}\${branch}\`);\n    });\n  }\n\n  // Utility methods\n  async getHeadCommit() {\n    const headPath = path.join(this.repoPath, '.logicgit', 'HEAD');\n    if (!fs.existsSync(headPath)) return null;\n    \n    const headContent = fs.readFileSync(headPath, 'utf8').trim();\n    \n    if (headContent.startsWith('ref:')) {\n      const refPath = headContent.substring(5).trim();\n      const fullRefPath = path.join(this.repoPath, '.logicgit', refPath);\n      if (fs.existsSync(fullRefPath)) {\n        const content = fs.readFileSync(fullRefPath, 'utf8').trim();\n        return content || null;\n      }\n    }\n    \n    return headContent || null;\n  }\n\n  async updateHead(commitHash) {\n    const headPath = path.join(this.repoPath, '.logicgit', 'HEAD');\n    const headContent = fs.readFileSync(headPath, 'utf8').trim();\n    \n    if (headContent.startsWith('ref:')) {\n      const refPath = headContent.substring(5).trim();\n      const fullRefPath = path.join(this.repoPath, '.logicgit', refPath);\n      fs.writeFileSync(fullRefPath, commitHash + '\\n');\n    } else {\n      // Detached HEAD\n      fs.writeFileSync(headPath, commitHash + '\\n');\n    }\n  }\n\n  async getExecution(hashPrefix) {\n    await this.initDatabase();\n    \n    return new Promise((resolve, reject) => {\n      this.db.get(\n        'SELECT * FROM executions WHERE execution_hash LIKE ? OR commit_hash LIKE ? ORDER BY timestamp DESC LIMIT 1',\n        [\`\${hashPrefix}%\`, \`\${hashPrefix}%\`],\n        (err, row) => err ? reject(err) : resolve(row)\n      );\n    });\n  }\n\n  generateHash(data) {\n    const content = typeof data === 'string' ? data : JSON.stringify(data, Object.keys(data).sort());\n    return crypto.createHash('sha1').update(content).digest('hex');\n  }\n\n  // Export execution data\n  async exportExecution(hashPrefix, outputPath = null) {\n    const execution = await this.getExecution(hashPrefix);\n    if (!execution) {\n      throw new Error(\`Execution \${hashPrefix} not found\`);\n    }\n\n    if (!outputPath) {\n      outputPath = path.join(this.repoPath, 'exports', \`execution_\${execution.execution_hash.substring(0, 8)}.json\`);\n    }\n\n    // Get audit trail\n    const auditTrail = await new Promise((resolve, reject) => {\n      this.db.all(\n        'SELECT * FROM audit_trail WHERE execution_hash = ? ORDER BY timestamp',\n        [execution.execution_hash],\n        (err, rows) => err ? reject(err) : resolve(rows)\n      );\n    });\n\n    // Get state snapshot\n    const snapshot = await new Promise((resolve, reject) => {\n      this.db.get(\n        'SELECT * FROM state_snapshots WHERE execution_hash = ? AND snapshot_type = "final"',\n        [execution.execution_hash],\n        (err, row) => err ? reject(err) : resolve(row)\n      );\n    });\n\n    const exportData = {\n      execution,\n      auditTrail,\n      finalState: snapshot ? JSON.parse(snapshot.state_data) : null,\n      exportTimestamp: new Date().toISOString(),\n      exportVersion: '1.0.0'\n    };\n\n    fs.writeFileSync(outputPath, JSON.stringify(exportData, null, 2));\n    console.log(\`üì§ Exported to: \${outputPath}\`);\n    return outputPath;\n  }\n\n  async close() {\n    if (this.db) {\n      await new Promise((resolve) => {\n        this.db.close((err) => {\n          if (err) console.error('Database close error:', err);\n          resolve();\n        });\n      });\n    }\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2);\n  const cmd = args[0];\n\n  try {\n    const git = new GitForLogic();\n\n    switch (cmd) {\n      case 'init':\n        console.log('üéØ Initialized Git for Logic repository');\n        console.log(\`üìÇ Location: \${git.repoPath}\`);\n        break;\n\n      case 'execute': {\n        const rulesFile = args[1];\n        const dataFile = args[2];\n        const message = args.slice(3).join(' ') || '';\n        \n        if (!rulesFile || !dataFile) {\n          console.log('Usage: node git-for-logic.js execute <rules.yaml> <data.json|csv> [message]');\n          return;\n        }\n        \n        await git.execute(rulesFile, dataFile, message);\n        break;\n      }\n\n      case 'log': {\n        const limit = parseInt(args[1]) || 10;\n        const branch = args[2];\n        await git.log(limit, branch);\n        break;\n      }\n\n      case 'diff': {\n        const hash1 = args[1];\n        const hash2 = args[2];\n        \n        if (!hash1 || !hash2) {\n          console.log('Usage: node git-for-logic.js diff <hash1> <hash2>');\n          return;\n        }\n        \n        await git.diff(hash1, hash2);\n        break;\n      }\n\n      case 'branch': {\n        if (args[1]) {\n          await git.createBranch(args[1]);\n        } else {\n          await git.listBranches();\n        }\n        break;\n      }\n\n      case 'checkout': {\n        const branchName = args[1];\n        if (!branchName) {\n          console.log('Usage: node git-for-logic.js checkout <branch>');\n          return;\n        }\n        await git.checkout(branchName);\n        break;\n      }\n\n      case 'export': {\n        const hash = args[1];\n        const outputPath = args[2];\n        \n        if (!hash) {\n          console.log('Usage: node git-for-logic.js export <execution-hash> [output-path]');\n          return;\n        }\n        \n        await git.exportExecution(hash, outputPath);\n        break;\n      }\n\n      default:\n        console.log(\`\nüéØ Git for Logic - Version Control for Business Rules\n\nCommands:\n  init                                   Initialize repository\n  execute <rules.yaml> <data.json> [msg] Execute rules and commit\n  log [count] [branch]                   Show execution history\n  diff <hash1> <hash2>                   Compare executions\n  branch [name]                          List branches or create new\n  checkout <branch>                      Switch branches\n  export <hash> [path]                   Export execution data\n\nExamples:\n  node git-for-logic.js init\n  node git-for-logic.js execute loan-rules.yaml applicants.csv "Risk assessment v2"\n  node git-for-logic.js log 5\n  node git-for-logic.js diff a1b2c3 d4e5f6\n  node git-for-logic.js branch experiment\n  node git-for-logic.js checkout experiment\n  node git-for-logic.js export a1b2c3d4 ./backup.json\n\nRepository Structure:\n  logic-repo/\n  ‚îú‚îÄ‚îÄ .logicgit/          # Version control data\n  ‚îú‚îÄ‚îÄ rules/              # YAML rule files\n  ‚îú‚îÄ‚îÄ data/               # Input data (JSON/CSV)\n  ‚îî‚îÄ‚îÄ exports/            # Exported executions\n        \`);\n    }\n\n    await git.close();\n\n  } catch (error) {\n    console.error('‚ùå Error:', error.message);\n    process.exit(1);\n  }\n}\n\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = GitForLogic;\n`,

};

// ======================================================================
// PUBLIC API (what to expose)
// ======================================================================

/**
 * Retrieve module source by name
 */
export function getModule(name: string): string {
  return MODULE_CONTENTS[name as keyof typeof MODULE_CONTENTS] || "";
}

/**
 * List modules, optionally filtered by layer
 */
export function listModules(layer?: string): string[] {
  if (layer) {
    return Object.entries(MODULE_MAP)
      .filter(([_, meta]) => meta.layer === layer)
      .map(([name]) => name);
  }
  return Object.keys(MODULE_CONTENTS);
}

/**
 * Get module dependencies
 */
export function getDependencies(name: string): string[] {
  return DEPENDENCY_GRAPH[name as keyof typeof DEPENDENCY_GRAPH] || [];
}

/**
 * Get statistics by layer
 */
export function getLayerStats(): Record<string, number> {
  return CALYX_METADATA.layers;
}

/**
 * Get external dependencies
 */
export function getExternalDeps(): string[] {
  return CALYX_METADATA.external_deps;
}

/**
 * Get package.json dependencies
 */
export function getPackageDeps(): Record<string, string> {
  return CALYX_METADATA.package_deps;
}

// ======================================================================
// RUNTIME SHIM (for Node.js execution)
// ======================================================================
if (typeof require !== "undefined" && require.cache) {
  // Only create packages that exist in our bundle
  const packages = new Set(
    Object.keys(MODULE_CONTENTS)
      .map(name => name.split(".")[0])
      .filter(Boolean)
  );

  for (const pkg of packages) {
    // Create package in require.cache
    const pkgName = `calyx.${pkg}`;
    const pkgModule = { exports: {} };
    require.cache[pkgName] = pkgModule;

    // Add submodules
    for (const [fullName, content] of Object.entries(MODULE_CONTENTS)) {
      if (fullName.startsWith(`${pkg}.`)) {
        const subName = fullName.slice(pkg.length + 1);
        const subFull = `${pkgName}.${subName}`;

        // Execute module in its own context
        const module = { exports: {} };
        const wrapper = `(function(exports, module) {
          ${content.replace(/\\/g, "\\\\").replace(/`/g, "\\`")}
        })`;
        try {
          eval(wrapper)(module.exports, module);
          require.cache[subFull] = { exports: module.exports };
          pkgModule.exports[subName] = module.exports;
        } catch (error) {
          console.error(`Failed to load ${subFull}:`, error);
        }
      }
    }
  }
}

// ======================================================================
// TYPE DECLARATIONS (for TypeScript awareness)
// ======================================================================
declare global {
  namespace Calyx {
    interface ModuleMetadata {
      path: string;
      layer: string;
      hasTypes: boolean;
      isReact: boolean;
      exports: string[];
    }

    interface Atlas {
      metadata: typeof CALYX_METADATA;
      modules: typeof MODULE_MAP;
      dependencies: typeof DEPENDENCY_GRAPH;
    }
  }
}

// ======================================================================
// MAIN ENTRY POINT (if run as script)
// ======================================================================
if (typeof module !== "undefined" && require.main === module) {
  console.log("CALYX TypeScript Bundle Loaded");
  console.log(`Modules: ${Object.keys(MODULE_CONTENTS).length}`);
  console.log(`Layers: ${JSON.stringify(getLayerStats())}`);
  console.log("");
  console.log("Available commands:");
  console.log("  - getModule(name)");
  console.log("  - listModules(layer)");
  console.log("  - getDependencies(name)");
  console.push("  - getLayerStats()");
  console.log("  - getExternalDeps()");
  console.log("  - getPackageDeps()");
}
